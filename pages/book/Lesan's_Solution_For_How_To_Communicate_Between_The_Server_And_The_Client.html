<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Lesan&#x27;s Solution For How To Communicate Between The Server And The Client - lesan</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="Receiving_Data.html"><strong aria-hidden="true">1.</strong> Receiving Data</a></li><li class="chapter-item expanded "><a href="Previous_methods_and_the_main_challenge.html"><strong aria-hidden="true">2.</strong> Previous methods and the main challenge</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Lesan's_Solution_For_How_To_Communicate_Between_The_Server_And_The_Client.html" class="active"><strong aria-hidden="true">2.1.</strong> Lesan's Solution For How To Communicate Between The Server And The Client</a></li><li class="chapter-item expanded "><a href="Why_NoSQL.html"><strong aria-hidden="true">2.2.</strong> Why noSQL?</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Penetration_Into_Depths.html"><strong aria-hidden="true">2.2.1.</strong> Penetration Into Depths</a></li></ol></li><li class="chapter-item expanded "><a href="Microservice.html"><strong aria-hidden="true">2.3.</strong> Microservice</a></li><li class="chapter-item expanded "><a href="Lesan_solution.html"><strong aria-hidden="true">2.4.</strong> Lesan solution</a></li></ol></li><li class="chapter-item expanded "><a href="Starting_work_with_Lesan.html"><strong aria-hidden="true">3.</strong> Starting work with Lesan</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Microservice_Architecture_with_Lesan.html"><strong aria-hidden="true">3.1.</strong> Microservice Architecture with Lesan</a></li></ol></li><li class="chapter-item expanded "><a href="Structures.html"><strong aria-hidden="true">4.</strong> Structures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="Schemas.html"><strong aria-hidden="true">4.1.</strong> Schemas</a></li><li class="chapter-item expanded "><a href="Pure_Structure_In_Schema.html"><strong aria-hidden="true">4.2.</strong> Pure Structure In Schema</a></li><li class="chapter-item expanded "><a href="The_InRelation_Structure_In_Schema.html"><strong aria-hidden="true">4.3.</strong> The InRelation Structure In Schema</a></li><li class="chapter-item expanded "><a href="The_structure_of_OutRelation_in_the_schema.html"><strong aria-hidden="true">4.4.</strong> The structure of OutRelation in the schema</a></li><li class="chapter-item expanded "><a href="The_structure_of_embed_in_the_schema.html"><strong aria-hidden="true">4.5.</strong> The structure of embed in the schema</a></li><li class="chapter-item expanded "><a href="The_structure_of_Struct_in_the_schema.html"><strong aria-hidden="true">4.6.</strong> The structure of Struct in the schema</a></li><li class="chapter-item expanded "><a href="runServer_(web_server_structure).html"><strong aria-hidden="true">4.7.</strong> runServer (web server structure)</a></li><li class="chapter-item expanded "><a href="Request_processing.html"><strong aria-hidden="true">4.8.</strong> Request processing</a></li><li class="chapter-item expanded "><a href="Dynamic_structure.html"><strong aria-hidden="true">4.9.</strong> Dynamic structure</a></li><li class="chapter-item expanded "><a href="Static_structure.html"><strong aria-hidden="true">4.10.</strong> Static structure</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">lesan</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="lesans-solution-for-how-to-communicate-between-the-server-and-the-client"><a class="header" href="#lesans-solution-for-how-to-communicate-between-the-server-and-the-client">Lesan's solution for how to communicate between the server and the client</a></h1>
<p>The idea of connecting client-side nodes to the backend in Lesan is inspired by GraphQL, but in Lesan we tried to make this connection simpler and more practical so that we can solve the problems mentioned above.</p>
<p>We focused on three points to do this:</p>
<ol>
<li>We do not add any language to the client and server (such as GQL language in GraphQL).</li>
<li>Instead of implementing complex logic to filter fields selected by the user, we use the logic implemented within databases (here Aggregation in MongoDB). Because algorithms implemented within databases have more scalability and efficiency due to direct data communication.</li>
<li>We store all relationships in data as embedded to reduce the amount of requests sent to the database.</li>
<li>Let’s create descriptive information for different types of data and how they are embedded in server-side logic so that we can create more efficient data models in the NoSQL style. We can also simplify data management in the database without changing the information.</li>
</ol>
<h2 id="proposed-method"><a class="header" href="#proposed-method">Proposed Method</a></h2>
<p>In the first step, we tried to organize the data structure because we intended to use NoSQL databases and at the same time we needed to have structured data like SQL both at runtime and during development to simplify the management of embedded data as much as possible.</p>
<p>We divided the relationships into two types of simple (inrelation) and complex or impossible (outrelation) for embedding. We stored simple relationships completely and stored complex relationships only in the number that could be returned in the first request (first pagination).</p>
<p>We exactly left the data retrieval management to the client as MongoDB had defined it, that is, sending an object with a key (data name) and a value (0 or 1) to the client.</p>
<p>We found a creative way to produce Aggregation Pipelines in MongoDB so that fewer documents are requested when receiving data as much as possible.</p>
<p>We allowed the client to see all the models and functions written on each model and choose them in the same object sent.</p>
<p>We allowed the client to see the output of each function written for each model along with the exact depth of its relationships that had previously been determined by the server-side programmer in a type-safe manner to make it easier to create the sent object.</p>
<p>We created an ODM to simplify the process of receiving data along with its relationships and also to manage the repetitions created from embedded relationships within this ODM so that the server-side programmer writes less code.</p>
<p>We prioritized input data validation and created a process for the server-side programmer to create a validator for each function written on each model so that we can run that validator before executing the function. In this validator, recursive data management along with the depth of penetration into the relationships of each model must be explicitly specified.</p>
<p>Let us clarify the issue with an example:
Let’s consider a schema named country with the following fields:</p>
<pre><code class="language-typescript">id;
name;
abb;
description;
geoLocation;
capital;
provinces;
cities;
</code></pre>
<p>And also a schema for the province with the following fields:</p>
<pre><code class="language-typescript">id;
name;
abb;
description;
geoLocation;
center;
country;
cities;
</code></pre>
<p>And also a schema for the city with the following fields:</p>
<pre><code class="language-typescript">id;
name;
abb;
description;
geoLocation;
country;
province;
</code></pre>
<p>The capital field in the country and the center field in the province are of type city and we completely embed them. This form of relationship is a simple relationship and we call it inrelation, which ultimately is a single object of the pure city fields (inrelations can also be multiple and be an array of objects) which is defined as follows:</p>
<pre><code class="language-typescript">countryInrelations = {
  capital: { schemaName: &quot;city&quot;, type: &quot;one&quot;, optional: false },
};
</code></pre>
<p>All country relationships do not end here. This schema also has a relationship with the province and city. With one simple question, we can complete the country’s relationships:</p>
<p>Is the number of provinces that we are going to keep inside the country too high? (i.e., if it is an SQL database, do we store the province key inside the country?)</p>
<p>Answer: No, the number of provinces is limited and we can store all provinces inside the country schema. So this relationship is also inrelation. Therefore, the above object should be created in this way:</p>
<pre><code class="language-typescript">countryInrelations = {
  capital: { schemaName: &quot;city&quot;, type: &quot;one&quot;, optional: false },
  provinces: { schemaName: &quot;province&quot;, type: &quot;many&quot;, optional: true },
};
</code></pre>
<p>Another relationship we have in the country is the city, how do we define it?</p>
<p>There are many cities in a country and we cannot store all the cities in a country schema.</p>
<p>So this is a complicated relationship with a large number, we define it as outrelation that the process of defining it requires more information to know exactly what amount and what data we are going to embed, we add that information in the sort key.</p>
<pre><code class="language-typescript">countryOutrelation = {
  cities: {
    schemaName: &quot;city&quot;,
    number: 50,
    sort: { field: &quot;_id&quot;, order: &quot;desc&quot;, type: &quot;objectId&quot; },
  },
};
</code></pre>
<p>We also define the remaining fields of the country that are specific to it and are not related to any relationship as pure fields.</p>
<pre><code class="language-typescript">countryPure: { name: string(), abb: optional(string()), ... }
</code></pre>
<p>For the province, it is the same way:</p>
<pre><code class="language-typescript">provinceInrelations = { center: { schemaName : &quot;city&quot;, type: &quot;one&quot; }, country: { schemaName: &quot;country&quot;, type: &quot;one&quot; }}
provinceOutrelation = { cities: { schemaName: &quot;city&quot;, number: 50, sort: { field: &quot; _id&quot;, order: &quot;desc&quot;, type: &quot;objectId&quot;}}}
provincePure: { name: string(), abb: optional(string()), ... }
</code></pre>
<p>And for the city, it is the same way:</p>
<pre><code class="language-typescript">cityInrelations = { country: { schemaName: &quot;country&quot;, type: &quot;one&quot; }, province: { schemaName: &quot;province&quot;, type: &quot;one&quot; } }
cityOutrelation = {}
cityPure: { name: string(), abb: string() , ... }
</code></pre>
<p>If you pay attention, every relation that is kept as inrelation in a schema, the related schema has also stored this schema as outrelation.</p>
<p>It is worth noting that we save this form of defining schemas in the integrated runtime in an object called Schemas. We will discuss its structure further. But what is stored in the database is the initial form that we showed earlier. It means for the country:</p>
<pre><code class="language-typescript">id;
name;
abb;
description;
geoLocation;
capital;
provinces;
cities;
</code></pre>
<p>The amount of pure fields is known. And the value of the fields that are of the relation type of schemas will be in the form of objects of the pure type of that relation. That is, for example, for the country:</p>
<pre><code class="language-typescript">{
id: &quot;234fwee656&quot;,
name: &quot;iran&quot;,
abb: &quot;ir&quot;,
description: &quot;a big country in asia&quot;,
geoLocation : [ [12,4], [32,45], ... ],
capital : {
	id: &quot;234fwee656&quot;,
	name: &quot;tehran&quot;,
	abb: &quot;th&quot;,
	description: &quot;the beautiful city in middle of iran&quot;,
	geoLocation : [ [12,4], [32,45], ... ]
},
provinces : [{
	id: &quot;234fwee656&quot;,
	name: &quot;tehran&quot;,
	abb: &quot;th&quot;,
	description: &quot;one of the irans provinces&quot;,
	geoLocation : [ [12,4], [32,45], ... ]
	},
	{

	id: &quot;234fwee656&quot;,
	name: &quot;hamedan&quot;,
	abb: &quot;hm&quot;,
	description: &quot;one of the irans provinces&quot;,
	geoLocation : [ [12,4], [32,45], ... ]
},
... til to end of the provinces
}],
cities :  [{
		id: &quot;234fwee656&quot;,
	name: &quot;tehran&quot;,
	abb: &quot;th&quot;,
	description: &quot;the beautiful city in middle of iran&quot;,
	geoLocation : [ [12,4], [32,45], ... ]
	},
	{
		Id: &quot;234fwee656&quot;,
	name: &quot;hamedan&quot;,
	abb: &quot;hm&quot;,
	description: &quot;one of the irans cities&quot;,
	geoLocation : [ [12,4], [32,45], ... ]
},
... til to end of the number limit for the first paginate
}],
</code></pre>
<p>Now the user can filter and receive all the fields of a schema along with the first depth of its relations by sending only one request to the database.</p>
<p>This request is performed based on the process of projection in MongoDB according to the values of fields being one or zero. Without our framework having any involvement in this process. And without us writing an additional layer to filter the requested fields in it. (The process and form of this request will be explained later.)</p>
<p>If the lower fields of a country’s schema are requested in a request, not only all the requested information will be received and returned to the user with one request to the server but also with one request to the database.</p>
<p>If the following fields are requested from the schema of a country in a request. Not only with a single request to the server but also with a single request to the database, all requested information will be received and returned to the user:</p>
<pre><code class="language-typescript">getCountry → id: 1
              Name: 1
		  abb: 1
		  decsription: 1
		  capital → id: 1
                  name: 1
			abb : 1
		  provinces → id :1
                  name :
			description : 1
		  cities → id : 1
                  name : 1
			abb : 1
</code></pre>
<p>If a user penetrates more than one level of depth, what should be done? For example, if they request provinces for a country, they may also want its cities from within the provinces.</p>
<pre><code class="language-typescript">
</code></pre>
<p>Let’s examine what happens in SQL databases before we explain the Lisan framework solution:</p>
<ul>
<li>
<p>First of all, we run a query to find the country, because we have the country ID, we run an indexed query.</p>
</li>
<li>
<p>After that, we run a query to find the capital, because we have its ID stored in the country, we run an indexed query.</p>
</li>
<li>
<p>Then we send a query to find the first paginate of provinces. If we have stored the ID of all the provinces of a country inside it, we run an indexed query. Otherwise, we must send an unindexed query with the country ID filter found.</p>
</li>
<li>
<p>Continuing with the example, if we had found 35 of the first paginate provinces. We should send a non-index query with a province ID filter for each one on each city and find the first paginated cities for each of the provinces. (For example, 50 for each province, which means 50 times 30)</p>
</li>
<li>
<p>Finally, to find the first paginate cities for this country too, we need to send a non-index query with the ID filter of the found country on the city table</p>
</li>
</ul>
<p>You saw that the process was very complicated in SQL, now let’s see how the same process is done in Lesan .</p>
<p>In the previous section, we mentioned that to get a country along with the first depth of its relationships (i.e., capital, states, and cities), we only send an indexed query to the schema of the country and receive all the information.</p>
<p>Now we only need to receive information about cities for each province.</p>
<p>To do this, while we have access to the information of the provinces, we send an indexed query to receive the provinces again.</p>
<p>Because of the concept of outrelation, we are sure that the information of cities is stored within provinces. Therefore, by receiving the provinces again, we will also receive the information of cities.</p>
<p>This will have two advantages for us. First, instead of sending a non-index query to the city, we send an index query to the province because we have received the province IDs in the first query.The second advantage is that instead of receiving a large number of cities, we have only received a few provinces. (For example, in SQL, the number of requested documents from the database is equal to 1 + 1 + (35 * 50) + 50. But in the Lesan method, only 1 + 35 documents have been requested.)</p>
<p>Now imagine what would happen if more depth and relationships were requested? This is the Achilles' heel of projects written with GraphQL.</p>
<h2 id="why-duplicate-data"><a class="header" href="#why-duplicate-data">Why duplicate data?</a></h2>
<p>As you noticed in the above example, if we can store all the dependencies of a table inside it, we can significantly reduce the number of requests sent to the database. This number is remarkably large. For example, in one of the best cases, if we have a table with 10 dependencies, each dependency is related to 10 other tables and all relationships are many-to-many. If we want to receive a list of 50 items from that table along with 2 steps of penetration into its relationships with one request, in SQL we should send 50 _ 10 _ 50 _ 10 which is equivalent to 250000 (two hundred and fifty thousand) requests sent to the database. But in Lesan all this data is collected with only 50 _ 10 which is equivalent to 500 requests sent to the database.</p>
<h2 id="the-ratio-of-creation-and-update-to-data-retrieval"><a class="header" href="#the-ratio-of-creation-and-update-to-data-retrieval">The Ratio Of Creation And Update To Data Retrieval</a></h2>
<p>Imagine a news database. We need a table for the authors and another table for the news written. Usually, at the end of each news, the name and some information of the author of that news are also included. If we place the information we need for the author of that news inside the news at the time of creation, we will not need to send a separate request to the database to receive the information of the author of that news when reading each news. But the problem arises when the author updates their information. For example, if they change their name from Ali to Ali Akbar. In this case, we have to update all the news written by that author. If this author writes an average of 10 news per day and works on this news website for more than 5 years, at least 18250 documents in the database must be updated. Is this cost-effective? In general, and in most cases, it can be cost-effective because news can be read more than a few thousand times a day and on the other hand, each author only changes their information once a year. Therefore, updating 18250 documents once a year is much less expensive than reading information from two different tables millions of times a day. Moreover, we have created a different solution for updating these repetitions called QQ, which updates them based on the amount of hardware resources used by the server side in different time periods and based on the value of the data. This process will be fully explained below.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="Previous_methods_and_the_main_challenge.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="Why_NoSQL.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="Previous_methods_and_the_main_challenge.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="Why_NoSQL.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
