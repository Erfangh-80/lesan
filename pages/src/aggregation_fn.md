# aggregation functions

We should use `Aggregation` when we want to penetrate more than one step in the depth of relationships, that is, if we want to go from father to grandson or vice versa.  
Don't worry, all the commands you need to penetrate the depths of the relationship and select their fields are automatically generated by **Lesan**.

The great thing about `Aggregation` in **Lesan** is that relationship penetration is always one step behind the client request. For more information about this please see [here](./Why_NoSQL.md#lesan-pipeline-example)  
We can use `aggregation` instead of `find` and `findOne`.

### Get list of documents with aggregation

Pay attention to the code written below:

```ts
const getCitiesAggregationValidator = () => {
  return object({
    set: object({
      page: number(),
      take: number(),
      countryId: optional(objectIdValidation),
    }),
    get: coreApp.schemas.selectStruct("city", 3),
  });
};
const getCitiesAggregation: ActFn = async (body) => {
  const {
    set: { page, take, countryId },
    get,
  } = body.details;
  const pipeline = [];

  pipeline.push({ $skip: (page - 1) * take });
  pipeline.push({ $limit: take });
  countryId &&
    pipeline.push({ $match: { "country._id": new ObjectId(countryId) } });

  return await cities
    .aggregation({
      pipeline,
      projection: get,
    })
    .toArray();
};

coreApp.acts.setAct({
  schema: "city",
  actName: "getCitiesAggregation",
  validator: getCitiesAggregationValidator(),
  fn: getCitiesAggregation,
});
```

In the code above, we have used `aggregation` to find the cities.  
As you can see, we have added two `pipelines` to create pagination by using `page` and `take` inputs, but these two `pipelines` are not all that is sent to the database. **Lesan** automatically creates `lookup`, `unwind` and `projection` pipelines based on `get` input. So that we can establish a `join` between the `schemas` and `select` and `return` the data requested by the user.

If this `request` is sent to the server:

```json
{
  "body": {
    "method": "POST",
    "headers": {
      "Content-Type": "application/json",
      "Authorization": ""
    },
    "body": {
      "service": "main",
      "model": "city",
      "act": "getCitiesAggregation",
      "details": {
        "get": {
          "_id": 1,
          "name": 1,
          "country": {
            "_id": 1,
            "name": 1
          },
          "users": {
            "_id": 1,
            "name": 1
          }
        },
        "set": {
          "page": 1,
          "take": 10
        }
      }
    }
  }
}
```

these `pipelines` will be created:

```json
[
  {
    "$project": {
      "_id": 1,
      "name": 1,
      "country": { "_id": 1, "name": 1 },
      "users": { "_id": 1, "name": 1 }
    }
  }
]
```

And if this `request` is sent to the server:

```json
{
  "body": {
    "method": "POST",
    "headers": {
      "Content-Type": "application/json",
      "Authorization": ""
    },
    "body": {
      "service": "main",
      "model": "city",
      "act": "getCitiesAggregation",
      "details": {
        "get": {
          "_id": 1,
          "name": 1,
          "country": {
            "_id": 1,
            "name": 1,
            "cities": {
              "_id": 1,
              "name": 1
            },
            "citiesByPopulation": {
              "name": 1,
              "_id": 1
            },
            "capital": {
              "_id": 1,
              "name": 1
            }
          },
          "users": {
            "_id": 1,
            "name": 1,
            "livedCities": {
              "name": 1,
              "_id": 1
            },
            "country": {
              "_id": 1,
              "name": 1
            }
          },
          "lovedByUser": {
            "_id": 1,
            "name": 1
          }
        },
        "set": {
          "page": 1,
          "take": 10
        }
      }
    }
  }
}
```

these `pipelines` will be created:

```json
[
  {
    "$lookup": {
      "from": "country",
      "localField": "country._id",
      "foreignField": "_id",
      "as": "country"
    }
  },
  {
    "$unwind": {
      "path": "$country",
      "preserveNullAndEmptyArrays": true
    }
  },
  {
    "$lookup": {
      "from": "user",
      "localField": "users._id",
      "foreignField": "_id",
      "as": "users"
    }
  },
  {
    "$project": {
      "_id": 1,
      "name": 1,
      "country": {
        "_id": 1,
        "name": 1,
        "cities": {
          "_id": 1,
          "name": 1
        },
        "citiesByPopulation": {
          "name": 1,
          "_id": 1
        },
        "capital": {
          "_id": 1,
          "name": 1
        }
      },
      "users": {
        "_id": 1,
        "name": 1,
        "livedCities": {
          "name": 1,
          "_id": 1
        },
        "country": {
          "_id": 1,
          "name": 1
        }
      },
      "lovedByUser": {
        "_id": 1,
        "name": 1
      }
    }
  }
]
```

Note that `pipelines` are always one step behind the `request`, and send `indexed` lookup with `_id` for anything. because we `embed` all relations.

Because we have given the second input `3` in the `coreApp.schemas.selectStruct("city", 3)` function, we can penetrate one more step in the depth of relationships, you can send more complex queries in the playground.

You can find full example [here](https://raw.githubusercontent.com/MiaadTeam/lesan/main/examples/document/07-1-aggregation.ts) and test the `aggregation` method in local computer.

executing `main` → `city` → `getCitiesAggregation`:
![aggregation-cities](https://github.com/MiaadTeam/lesan/assets/6236123/1e6610c7-fe20-4772-84fd-d2916a082f62)

### Add E2E Test

Like before, for adding `getCitiesAggregation` request to E2E test section, you should click on the **E2E button**, like bottom picture.

<img width="1680" alt="e2e sequence" src="https://github.com/MiaadTeam/lesan/assets/96171913/fae58c10-f792-4041-89ca-186dc89bcee1">

Then, in the E2E section and `getCitiesAggregation` sequence, you should _replace_ the **country id** that you set capture in _own sequence_ with _default_ **country id**. _default_ **country id** in `getCitiesAggregation` sequence is like below picture.

<img width="1680" alt="e2e sequence" src="https://github.com/MiaadTeam/lesan/assets/96171913/bb0f2f25-6542-450b-9347-1f388abb8439">

The _replaced_ **country id** is like below picture.

<img width="1680" alt="e2e sequence" src="https://github.com/MiaadTeam/lesan/assets/96171913/82479f3a-049e-4d76-967d-3cadc335fce0">

### Get a one document with aggregation

Because we may request the relations of a document more than one step and if we want to use `lookup` between two schemas, we have to use `aggregation` even to receive a document.

Enter the following code to find `a user`:

```ts
const getUserAggregationValidator = () => {
  return object({
    set: object({
      userId: objectIdValidation,
    }),
    get: coreApp.schemas.selectStruct("user", 2),
  });
};
const getUserAggregation: ActFn = async (body) => {
  const {
    set: { userId },
    get,
  } = body.details;
  const pipeline = [];

  pipeline.push({ $match: { _id: new ObjectId(userId) } });

  return await users
    .aggregation({
      pipeline,
      projection: get,
    })
    .toArray();
};

coreApp.acts.setAct({
  schema: "user",
  actName: "getUserAggregation",
  validator: getUserAggregationValidator(),
  fn: getUserAggregation,
});
```

Note that the returned information will still be in an `array` but with one member.

You can find full example [here](https://raw.githubusercontent.com/MiaadTeam/lesan/main/examples/document/06-find-one.ts) and test the `aggregation` method in local computer.

executing `main` → `user` → `getUserAggregation`:
![aggregation-user](https://github.com/MiaadTeam/lesan/assets/6236123/54522471-cd4d-42dd-abd8-040663bcbb6c)

### Add E2E Test

For adding `getUserAggregation` request to E2E test section, you should click on the **E2E button**, like bottom picture.

<img width="1680" alt="e2e sequence" src="https://github.com/MiaadTeam/lesan/assets/96171913/fae58c10-f792-4041-89ca-186dc89bcee1">

Then, in the E2E section and `getUserAggregation` sequence, you should _replace_ the **user id** that you set capture in _own sequence_ with _default_ **user id**. default **user id** in `getUserAggregation` sequence is like below picture.

<img width="1680" alt="e2e sequence" src="https://github.com/MiaadTeam/lesan/assets/96171913/88c3e30b-8249-474f-b159-548ab7eaf805">

The _replaced_ **user id** is like below picture.

<img width="1680" alt="e2e sequence" src="https://github.com/MiaadTeam/lesan/assets/96171913/d8143ffa-146e-4569-8bb0-faec9270642e">
